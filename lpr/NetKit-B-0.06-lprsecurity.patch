From owner-linux-security@tarsier.cv.nrao.edu Sat Jul 22 23:03:16 1995
Received: from tarsier.cv.nrao.edu (tarsier.cv.nrao.edu [192.33.115.50]) by redhat.com (8.6.11/8.6.9) with ESMTP id XAA31182 for <marc@redhat.com>; Sat, 22 Jul 1995 23:03:05 -0400
Received: (from majdom@localhost) by tarsier.cv.nrao.edu (8.6.12/8.6.9) id TAA18149; Sat, 22 Jul 1995 19:00:30 -0400
Received: from brewhq.swb.de (root@brewhq.swb.de [193.175.30.3]) by tarsier.cv.nrao.edu (8.6.12/8.6.9) with SMTP id SAA18110; Sat, 22 Jul 1995 18:42:58 -0400
Received: by brewhq.swb.de (Linux Smail3.1.29.0 #5)
	id m0sZnFc-0005BKC; Sun, 23 Jul 95 00:42 MET DST
Received: by monad.swb.de (smail3.1.29.0 #5)
	id m0sZncc-00000WC; Sun, 23 Jul 95 01:06 MET DST
Message-Id: <m0sZncc-00000WC@monad.swb.de>
From: okir@monad.swb.de (Olaf Kirch)
Subject: Tentative fix for BSD lpr
To: linux-security@tarsier.cv.nrao.edu
Date: Sun, 23 Jul 1995 01:06:13 +0200 (MET DST)
Cc: flla@stud.uni-sb.de (Florian La Roche)
X-Mailer: ELM [version 2.4 PL23]
MIME-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
Content-Length: 6178      
Sender: owner-linux-security@tarsier.cv.nrao.edu
Precedence: list
Status: RO

-----BEGIN PGP SIGNED MESSAGE-----


Hi all,

here's a patch to the BSD lpr stuff from NetKit-B-0.05. Apart from the
bug Zygo Blaxell reported, I stumbled across some more.

 *	lpr -r and lpr -r -s would remove arbitrary files in some cases.
	Unfortunately, the file removal code is scattered throughout
	several programs and source files. I found the following places:

	 lpr:	after the job has been spooled (lpr -r)
	 lpd:	after the job has been successfully printed (lpr -r -s)
	 lprm:	when removing a pending job (lpr -r -s)

	Unlinking now always happens under the euid/egid of the user who
	submitted the job. This is easy for lpr, but slightly more
	difficult for lpd/lprm. Trusting that the job description files
	are ok, I extract the user and host name and match them against
	hosts.equiv and .rhosts to make sure the accounts are
	equivalent.

	There's a tiny difference between lpd and lprm: lpd still has
	the FQDN of the original submitter's host, while lprm has to use
	the host information from the job description file (currently
	not checked against the sender's hostname).

 *	Made the /dev/printer Unix socket mode 600. It used to be
	777 thus allowing anyone to submit faked jobs with false
	credentials.

 *	Avoid the FTP bounce attack.

 *	Fixed a possible stack overwrite problem in rmjob.c. I have the
	feeling that this is not the only one... can you say RTM?

Please let me know if it works for you. I'll send out the patch to
linux-alert in a few days if no-one complains, or if someone comes up
with a cleaner one.

If anyone knows where to reach the BSD people who maintain this beast,
please drop me a note.

Have a nice day everyone,
Olaf
- -- 
Olaf Kirch         |  --- o --- Nous sommes du soleil we love when we play
okir@monad.swb.de  |    / | \   sol.dhoop.naytheet.ah kin.ir.samse.qurax
             For my PGP public key, finger okir@brewhq.swb.de.
-----BEGIN PGP SIGNATURE-----
Version: 2.6

iQCVAgUBMBGEIOFnVHXv40etAQFQmgQAlBDi+2eKPQAWWq5e/ddyZTJbtY1JSUr6
9L3pb+Xu8sPm2tO65HysxCZiOyLslFQFzMlDZWEBh2Ic0iXYiuv+90BWgOOGzaaq
Jzsp48fe2K5HnD7jBD/qyhPsMtTxFgPh7mfznCJTV/ziHJDaoWBRIcDu5geDJtC4
V0T9gvnM50A=
=q2aq
-----END PGP SIGNATURE-----

diff -ur lpr.orig/common_source/rmjob.c lpr/common_source/rmjob.c
--- lpr.orig/common_source/rmjob.c	Wed Jun  8 16:22:40 1994
+++ lpr/common_source/rmjob.c	Sun Jul 23 00:11:30 1995
@@ -176,6 +176,7 @@
 	char *file;
 {
 	FILE *cfp;
+	char logname[32] = "";
 
 	if (!chk(file))
 		return;
@@ -183,11 +184,18 @@
 		fatal("cannot open %s", file);
 	while (getline(cfp)) {
 		switch (line[0]) {
+		case 'P':
+			strncpy(logname, line+1, sizeof(logname)-1);
+			logname[sizeof(logname)-1] = '\0';
+			break;
 		case 'U':  /* unlink associated files */
 			if (from != host)
 				printf("%s: ", host);
-			printf(unlink(line+1) ? "cannot dequeue %s\n" :
-				"%s dequeued\n", line+1);
+			if (dounlink(line+1, from, logname))
+				printf("cannot dequeue %s\n", line+1);
+			else
+				printf("%s dequeued\n", line+1);
+			break;
 		}
 	}
 	(void) fclose(cfp);
@@ -203,7 +211,7 @@
 	char *file;
 {
 	register int *r, n;
-	char **u, *cp, p[64], h[64];
+	char **u, *cp, p[64], h[257];
 	FILE *cfp;
 
 	/*
@@ -219,10 +227,13 @@
 	if ((cfp = fopen(file, "r")) == NULL)
 		return(0);
 	while (getline(cfp)) {
-		if (line[0] == 'P')
-			strcpy(p, line+1);
-		else if (line[0] == 'H')
-			strcpy(h, line+1);
+		if (line[0] == 'P') {
+			strncpy(p, line+1, sizeof(p)-1);
+			p[sizeof(p)-1] = '\0';
+		} else if (line[0] == 'H') {
+			strncpy(h, line+1, sizeof(h)-1);
+			h[sizeof(h)-1] = '\0';
+		}
 	}
 	(void) fclose(cfp);
 
@@ -311,6 +322,36 @@
 			(void) fwrite(buf, 1, i, stdout);
 		(void) close(rem);
 	}
+}
+
+/*
+ * Unlink a file.
+ */
+int
+dounlink(file, host, user)
+	char *file;
+	char *host;
+	char *user;
+{
+	struct passwd	*pw;
+	uid_t		euid = geteuid();
+	gid_t		egid = getegid();
+	int		ret;
+
+	if (file[0] != '/')
+		return unlink(file);
+
+	if (euid || !user[0]
+	 || from != host && ruserok(host, 0, user, user) < 0
+	 || (pw = getpwnam(user)) == NULL
+	 || setegid(pw->pw_gid) < 0 || seteuid(pw->pw_uid) < 0)
+		return -1;
+
+	ret = unlink(file);
+	if (seteuid(euid) < 0 || setegid(egid) < 0)
+		fatal("Couldn't reset effective uid/gid after unlink()");
+
+	return ret;
 }
 
 /*
diff -ur lpr.orig/lpd/lpd.c lpr/lpd/lpd.c
--- lpr.orig/lpd/lpd.c	Mon May 23 11:05:02 1994
+++ lpr/lpd/lpd.c	Sun Jul 23 00:14:34 1995
@@ -159,6 +159,7 @@
 		syslog(LOG_ERR, "ubind: %m");
 		exit(1);
 	}
+	chmod(_PATH_SOCKETNAME, 0600);	/* we called umask(0) above... */
 	sigsetmask(omask);
 	defreadfds = 1 << funix;
 	listen(funix, 5);
@@ -262,8 +263,8 @@
 int	requests;		/* # of spool requests */
 char	*person;		/* name of person doing lprm */
 
-char	fromb[32];	/* buffer for client's machine name */
-char	cbuf[BUFSIZ];	/* command line buffer */
+char	fromb[257];		/* buffer for client's machine name */
+char	cbuf[BUFSIZ];		/* command line buffer */
 char	*cmdnames[] = {
 	"null",
 	"printjob",
@@ -419,13 +420,13 @@
 	register struct hostent *hp;
 	register FILE *hostf;
 	register char *cp, *sp;
-	char ahost[50];
 	int first = 1;
 	extern char *inet_ntoa();
 	int baselen = -1;
 
 	f->sin_port = ntohs(f->sin_port);
-	if (f->sin_family != AF_INET || f->sin_port >= IPPORT_RESERVED)
+	if (f->sin_family != AF_INET || f->sin_port >= IPPORT_RESERVED ||
+	    f->sin_port < IPPORT_RESERVED/2)
 		fatal("Malformed from address");
 	hp = gethostbyaddr((char *)&f->sin_addr,
 	    sizeof(struct in_addr), f->sin_family);
@@ -438,22 +439,18 @@
 	if (!strcmp(from, host))
 		return;
 
-	sp = fromb;
-	cp = ahost;
-	while (*sp) {
+	for (sp = fromb; *sp && cp < (fromb + sizeof(fromb) - 1); sp++) {
 		if (*sp == '.') {
 			if (baselen == -1)
 				baselen = sp - fromb;
-			*cp++ = *sp++;
-		} else {
-			*cp++ = isupper(*sp) ? tolower(*sp++) : *sp++;
+		} else if (isupper(*sp)) {
+			*sp = tolower(*sp);
 		}
 	}
-	*cp = '\0';
 	hostf = fopen(_PATH_HOSTSEQUIV, "r");
 again:
 	if (hostf) {
-		if (!_validuser(hostf, ahost, DUMMY, DUMMY, baselen)) {
+		if (!_validuser(hostf, fromb, DUMMY, DUMMY, baselen)) {
 			(void) fclose(hostf);
 			return;
 		}
diff -ur lpr.orig/lpd/printjob.c lpr/lpd/printjob.c
--- lpr.orig/lpd/printjob.c	Mon May 23 11:05:02 1994
+++ lpr/lpd/printjob.c	Sun Jul 23 00:46:11 1995
@@ -59,6 +59,7 @@
 #define	NOACCT		2
 #define	FILTERERR	3
 #define	ACCESS		4
+#define UNLINK		5
 
 char	title[80];		/* ``pr'' title */
 FILE	*cfp;			/* control file */
@@ -74,7 +75,7 @@
 dev_t	fdev;			/* device of file pointed to by symlink */
 ino_t	fino;			/* inode of file pointed to by symlink */
 
-char	fromhost[32];		/* user's host machine */
+char	fromhost[257];		/* user's host machine */
 char	logname[32];		/* user's login name */
 char	jobname[100];		/* job or file name */
 char	class[32];		/* classification field */
@@ -312,7 +313,7 @@
 	while (getline(cfp))
 		switch (line[0]) {
 		case 'H':
-			strcpy(fromhost, line+1);
+			strncpy(fromhost, line+1, sizeof(fromhost)-1);
 			if (class[0] == '\0')
 				strncpy(class, line+1, sizeof(class)-1);
 			continue;
@@ -369,7 +370,8 @@
 		case '3':
 		case '4':
 			if (line[1] != '\0')
-				strcpy(fonts[line[0]-'1'], line+1);
+				strncpy(fonts[line[0]-'1'], line+1,
+					sizeof(fonts[0])-1);
 			continue;
 
 		case 'W':	/* page width */
@@ -420,7 +422,7 @@
 			continue;
 
 		case 'U':
-			(void) unlink(line+1);
+			(void) unlinkfile(line+1, from, logname);
 		}
 	/*
 	 * clean-up in case another control file exists
@@ -733,7 +735,7 @@
 	fseek(cfp, 0L, 0);
 	while (getline(cfp))
 		if (line[0] == 'U')
-			(void) unlink(line+1);
+			(void) unlinkfile(line+1, from, logname);
 	/*
 	 * clean-up in case another control file exists
 	 */
@@ -935,6 +937,18 @@
 }
 
 /*
+ * Safely (I hope) unlink a file.
+ */
+unlinkfile(file, host, user)
+	char *file;
+	char *host;
+	char *user;
+{
+	if (dounlink(file, host, user))
+		sendmail(file, UNLINK);
+}
+
+/*
  * sendmail ---
  *   tell people about job completion
  */
@@ -992,6 +1006,10 @@
 			break;
 		case ACCESS:
 			printf("\nwas not printed because it was not linked to the original file\n");
+			break;
+		case UNLINK:
+			printf("\nwas not unlinked: permission denied\n");
+			break;
 		}
 		fflush(stdout);
 		(void) close(1);
diff -ur lpr.orig/lpr/lpr.c lpr/lpr/lpr.c
--- lpr.orig/lpr/lpr.c	Mon May 23 11:05:02 1994
+++ lpr/lpr/lpr.c	Sun Jul 23 00:17:35 1995
@@ -346,7 +346,7 @@
 		}
 		copy(i, arg);
 		(void) close(i);
-		if (f && unlink(arg) < 0)
+		if (f && unlinkfile(arg) < 0)
 			printf("%s: %s: not removed\n", name, arg);
 	}
 
@@ -602,6 +602,7 @@
 	}
 #endif
 	(void) close(fd);
+#if 0
 	if (rflag) {
 		if ((cp = rindex(file, '/')) == NULL) {
 			if (access(".", 2) == 0)
@@ -616,11 +617,37 @@
 		printf("%s: %s: is not removable by you\n", name, file);
 	}
 	return(0);
+#else
+	return rflag;
+#endif
 
 error1:
 	printf(" and is unprintable\n");
 	(void) close(fd);
 	return(-1);
+}
+
+int
+unlinkfile(file)
+	register char *file;
+{
+	uid_t	euid = geteuid();
+	gid_t	egid = getegid();
+	int	err;
+
+	if (setegid(getgid()) < 0)
+		return 0;
+	if (seteuid(getuid()) < 0)
+		return 0;
+	if ((err = unlink(file)) < 0) {
+		printf("%s: %s: couldn't remove file: %s\n",
+				name, file, strerror(errno));
+	}
+	if (seteuid(euid) < 0 || setegid(egid) < 0) {
+		printf("%s: couldn't reset effective uid/gid!\n", name);
+		cleanup();
+	}
+	return (err >= 0);
 }
 
 /*
